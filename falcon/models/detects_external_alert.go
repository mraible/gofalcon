// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DetectsExternalAlert detects external alert
//
// swagger:model detects.ExternalAlert
type DetectsExternalAlert struct {

	// Device or sensor ID for which the Alert was generated
	// Required: true
	AgentID *string `json:"agent_id"`

	// Common linkage between multiple Alerts that belong to the same detection bouquet
	// Required: true
	AggregateID *string `json:"aggregate_id"`

	// Name of the person this Alert is assigned to
	// Required: true
	AssignedToName *string `json:"assigned_to_name"`

	// UserID to which this Alert is assigned to
	// Required: true
	AssignedToUID *string `json:"assigned_to_uid"`

	// UUID to which this Alert is assigned to
	// Required: true
	AssignedToUUID *string `json:"assigned_to_uuid"`

	// Unique ID of CrowdStrike customers
	// Required: true
	Cid *string `json:"cid"`

	// An opaque internal identifier that can uniquely identify an Alert
	// Required: true
	CompositeID *string `json:"composite_id"`

	// Confidence is a 1-100 integer value denoting the confidence that, when this Alert fires, it is indicative of malicious activity
	// Required: true
	Confidence *int64 `json:"confidence"`

	// indicates when ThreatGraph was crawled to gather info for this alert creation/update
	// Required: true
	// Format: date-time
	CrawledTimestamp *strfmt.DateTime `json:"crawled_timestamp"`

	// indicates when the Alert was first written to backend store
	// Required: true
	// Format: date-time
	CreatedTimestamp *strfmt.DateTime `json:"created_timestamp"`

	// Data Domains represents domains to which this alert belongs to
	// Required: true
	DataDomains []string `json:"data_domains"`

	// Short, customer-visible summary of the detected activity
	// Required: true
	Description *string `json:"description"`

	// Customer visible name for the Alert&#39;s pattern
	// Required: true
	DisplayName *string `json:"display_name"`

	// Boolean to know if we sent email regarding this Alert
	// Required: true
	EmailSent *bool `json:"email_sent"`

	// Boolean indicating if this Alert is internal or external
	// Required: true
	External *bool `json:"external"`

	// Vertex key which triggers the formation of the Alert
	// Required: true
	ID *string `json:"id"`

	// Pattern Name coming either from Taxonomy or directly from the ingested Alert
	// Required: true
	Name *string `json:"name"`

	// End goal that an attack adversary intends to achieve according to MITRE
	// Required: true
	Objective *string `json:"objective"`

	// Taxonomy patternID for this Alert
	// Required: true
	PatternID *int64 `json:"pattern_id"`

	// Platform that this Alert was triggered on e.g. Android, Windows, etc..
	// Required: true
	Platform *string `json:"platform"`

	// Product specifies the SKU that this Alert belongs to e.g. mobile, idp, epp
	// Required: true
	Product *string `json:"product"`

	// Scenario was used pre-Handrails to display additional killchain context for UI alerts. With handrails, this field is mostly  obsolete in favor of tactic/technique. Still, it can be useful for determining specific pattern types that are not straightforward to distinguish from other fields alone
	// Required: true
	Scenario *string `json:"scenario"`

	// Seconds To Resolved represents the seconds elapsed since this alert has been resolved
	// Required: true
	SecondsToResolved *int64 `json:"seconds_to_resolved"`

	// Seconds To Triage represents the seconds elapsed since this alert has been triaged
	// Required: true
	SecondsToTriaged *int64 `json:"seconds_to_triaged"`

	// Severity is also a 1-100 integer value, but unlike confidence severity impacts how a Alert is displayed in the UI
	// Required: true
	Severity *int64 `json:"severity"`

	// Severity name is a UI friendly bucketing of the severity integer
	// Required: true
	SeverityName *string `json:"severity_name"`

	// Boolean indicating if this Alert will be shown in the UI or if it&#39;s hidden&#39;
	// Required: true
	ShowInUI *bool `json:"show_in_ui"`

	// Source Products are products that produced events which contributed to this alert
	// Required: true
	SourceProducts []string `json:"source_products"`

	// Source Vendors are vendors that produced events which contributed to this alert
	// Required: true
	SourceVendors []string `json:"source_vendors"`

	// Could be one of the following - New, closed, in_progress, reopened
	// Required: true
	Status *string `json:"status"`

	// Tactic and Technique are references to MITRE ATT&amp;CK, which is a public framework for tracking and modeling adversary tools techniques and procedures
	// Required: true
	Tactic *string `json:"tactic"`

	// Unique ID for the tactic seen in the Alert
	// Required: true
	TacticID *string `json:"tactic_id"`

	// Tags are string values associated with the alert that can be added or removed through the API
	// Required: true
	Tags []string `json:"tags"`

	// Tactic and Technique are references to MITRE ATT&amp;CK, which is a public framework for tracking and modeling adversary tools techniques and procedures
	// Required: true
	Technique *string `json:"technique"`

	// Unique ID for the technique seen in the Alert
	// Required: true
	TechniqueID *string `json:"technique_id"`

	// stored value coming in directly from the ingested event or set by cloud in the absence of it
	// Required: true
	// Format: date-time
	Timestamp *strfmt.DateTime `json:"timestamp"`

	// Type of definition Detections Extensibility use. Keyed-off of Pattern of the incoming events/Alerts
	// Required: true
	Type *string `json:"type"`

	// indicates when the Alert was last modified
	// Required: true
	// Format: date-time
	UpdatedTimestamp *strfmt.DateTime `json:"updated_timestamp"`
}

// Validate validates this detects external alert
func (m *DetectsExternalAlert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgentID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssignedToName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssignedToUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAssignedToUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompositeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrawledTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataDomains(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailSent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjective(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePatternID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlatform(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProduct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScenario(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondsToResolved(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecondsToTriaged(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverityName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShowInUI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceVendors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTactic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTacticID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTechnique(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTechniqueID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DetectsExternalAlert) validateAgentID(formats strfmt.Registry) error {

	if err := validate.Required("agent_id", "body", m.AgentID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateAggregateID(formats strfmt.Registry) error {

	if err := validate.Required("aggregate_id", "body", m.AggregateID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateAssignedToName(formats strfmt.Registry) error {

	if err := validate.Required("assigned_to_name", "body", m.AssignedToName); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateAssignedToUID(formats strfmt.Registry) error {

	if err := validate.Required("assigned_to_uid", "body", m.AssignedToUID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateAssignedToUUID(formats strfmt.Registry) error {

	if err := validate.Required("assigned_to_uuid", "body", m.AssignedToUUID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateCid(formats strfmt.Registry) error {

	if err := validate.Required("cid", "body", m.Cid); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateCompositeID(formats strfmt.Registry) error {

	if err := validate.Required("composite_id", "body", m.CompositeID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateConfidence(formats strfmt.Registry) error {

	if err := validate.Required("confidence", "body", m.Confidence); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateCrawledTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("crawled_timestamp", "body", m.CrawledTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("crawled_timestamp", "body", "date-time", m.CrawledTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateCreatedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("created_timestamp", "body", m.CreatedTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("created_timestamp", "body", "date-time", m.CreatedTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateDataDomains(formats strfmt.Registry) error {

	if err := validate.Required("data_domains", "body", m.DataDomains); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("display_name", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateEmailSent(formats strfmt.Registry) error {

	if err := validate.Required("email_sent", "body", m.EmailSent); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateExternal(formats strfmt.Registry) error {

	if err := validate.Required("external", "body", m.External); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateObjective(formats strfmt.Registry) error {

	if err := validate.Required("objective", "body", m.Objective); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validatePatternID(formats strfmt.Registry) error {

	if err := validate.Required("pattern_id", "body", m.PatternID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validatePlatform(formats strfmt.Registry) error {

	if err := validate.Required("platform", "body", m.Platform); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateProduct(formats strfmt.Registry) error {

	if err := validate.Required("product", "body", m.Product); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateScenario(formats strfmt.Registry) error {

	if err := validate.Required("scenario", "body", m.Scenario); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSecondsToResolved(formats strfmt.Registry) error {

	if err := validate.Required("seconds_to_resolved", "body", m.SecondsToResolved); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSecondsToTriaged(formats strfmt.Registry) error {

	if err := validate.Required("seconds_to_triaged", "body", m.SecondsToTriaged); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSeverity(formats strfmt.Registry) error {

	if err := validate.Required("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSeverityName(formats strfmt.Registry) error {

	if err := validate.Required("severity_name", "body", m.SeverityName); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateShowInUI(formats strfmt.Registry) error {

	if err := validate.Required("show_in_ui", "body", m.ShowInUI); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSourceProducts(formats strfmt.Registry) error {

	if err := validate.Required("source_products", "body", m.SourceProducts); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateSourceVendors(formats strfmt.Registry) error {

	if err := validate.Required("source_vendors", "body", m.SourceVendors); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTactic(formats strfmt.Registry) error {

	if err := validate.Required("tactic", "body", m.Tactic); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTacticID(formats strfmt.Registry) error {

	if err := validate.Required("tactic_id", "body", m.TacticID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTags(formats strfmt.Registry) error {

	if err := validate.Required("tags", "body", m.Tags); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTechnique(formats strfmt.Registry) error {

	if err := validate.Required("technique", "body", m.Technique); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTechniqueID(formats strfmt.Registry) error {

	if err := validate.Required("technique_id", "body", m.TechniqueID); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("timestamp", "body", m.Timestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *DetectsExternalAlert) validateUpdatedTimestamp(formats strfmt.Registry) error {

	if err := validate.Required("updated_timestamp", "body", m.UpdatedTimestamp); err != nil {
		return err
	}

	if err := validate.FormatOf("updated_timestamp", "body", "date-time", m.UpdatedTimestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this detects external alert based on context it is used
func (m *DetectsExternalAlert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DetectsExternalAlert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DetectsExternalAlert) UnmarshalBinary(b []byte) error {
	var res DetectsExternalAlert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
